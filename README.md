# IJVM-Emulator

This is the source code for my IJVM-Emulator. Enjoy :).

## Bonus assignments

I completed the following four bonus assignments.

### Code hardening 10%

For this assignment I first focused on bounds checking. Meaning that every time the program handles * arrays, it would need to check if it was requesting an index which was either negative or larger than the array. This first included `stack_data`, `local_data`, `text`, and `constants`.

Next, I did some error 'handling' on alloc functions: checking for nullpointers as a result. I focused on making sure to free allocated memory when detecting those. My TA told me, however, that when a program exits it usually frees the block automatically. It doesn't make sense for me to revert it though so I'll keep it.

Finally, I did some fuzzing to check if I had caught all issues. Of course, I had not. I was surprised by many segmentation faults and fixed them after. The issues mostly included forgotten bounds checking, but also showed up in `doINVOKEVIRTUAL`: there could be an overflow in the addition of `local_size` and `n_args` causing not enough memory to be allocated. I noticed that many crashes were caused by the presence of the `IN` instruction. I also saw loads of hangs that I think were caused by the accidental creation of loops in the program. I don't think I can do anything simple about. In the end, I did about 3 runs of fuzzing more than an hour.

Of course, I also passed all the pedantic, leaks, and sanitizer tests.

### Heap + Garbage Collector 15%

The heap and garbage collector are actually quite simple and probably far too inefficient, but whatever.

I made two structs:  
`array_t`: Stores array's size, reference and data.  
`arrays_t`: Keeps track of all the arrays allocated.

I thought about where the `ref` could be stored and I found that it could only be stored in a programs `local_data` and `stack_data`. The constant pool is read-only.

References are generated by random (srand(time()), rand()). This means that there is a very small chance that a random value on the stack or local's could unintentionally also be a reference to an array causing it to be not deleted. I guess its better to not delete than the other way around...

At every IRETURN (and `OP_GC`) the garbage collector is called. The garbage collector is similar to mark and sweep in that in will first do a round of searching for lost references and another round for 'copying' or 'removing' lost references.

Round 1: recursive search in each possible value in stack and locals and check if their value corresponds to a reference. Mark an array's `wipe` member as true if it can't be found.

Round 2: copy every array which has not been marked with `wipe` to a new `arrays_t` and free the others.

Finally, replace the previous `arrays_t` with the (smaller) new `arrays_t`.

### IJVM-GUI 10%

For this bonus assignment I used nuklear on X11. Tested on WSL2 with VcXsrv. Run `make ijvm-gui` to compile into `ijvm-gui`. I used the X11 sample template given in their [repo](https://github.com/vurtun/nuklear/tree/master/demo/x11).

Usage: `./ijvm-gui binary`

Features:
* Load input from textfield
* Show output
* Stepping by value or run until EOF.
* View current `pc` and next instruction.
* View content `stack` and `local` data for each frame
* View `array_t` reference and contents
* Reset IJVM state (reload gui)

I assumed the code-style grade and code hardening would not include the code written in this assignment.

### Network Communication 15%

I implemented this bonus assignment early on but really did not like the way the tests were given. Although this assignment is included in the source code, it may be regarded as not present. Since I finished three other bonus assignments (= 35%) it does not matter anyways. I'm pretty sure everything works though :).

I would have loved to do some more assignments but I unfortunately could not find the time. Might do some more during the summer.
